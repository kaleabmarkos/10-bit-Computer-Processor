A project for CSC 244 Digital Logic Lab

by Kaleab Gessese and Hayden Eischens


This project introduces a versatile 10-bit computer processor designed and implemented on the DE10-Lite FPGA board. The primary objective is to explore the efficiency of lower bit-width processors, specifically tailored for applications where precision beyond 10 bits is unnecessary. The real-world applications target scenarios such as sensor networks, emphasizing power efficiency and resource constraints. The DE10-Lite board, featuring a Cyclone IV FPGA, serves as the hardware platform for our implementation. The processor is made using both custom logic blocks and ready-made modules in the FPGA. This mix optimizes how resources are used while still keeping everything working well.

I use the seven-segment displays on the DE10-Lite board to show the data output, making it easy for users without going into detailed pin configurations. The successful implementation of this 10-bit processor demonstrates its reliability in handling computations and compatibility with diverse input sources. The use of seven-segment displays enhances user experience and real-time monitoring of processed data. This project's significance lies in showcasing the adaptability and efficiency achievable through custom processor design, providing a cost-effective and energy-efficient solution for targeted applications within the FPGA-based computing landscape. The system takes inputs from switches, clock button, and peek button, producing outputs including the current state of the shared data bus, ALU result, and current timestep. The instruction register temporarily stores the current instruction for decoding, while the counter manages program flow and memory addresses. The register file stores four 10-bit registers with one write and two read ports for data storage. The multi-stage ALU performs arithmetic and logic operations. The controller coordinates control signals based on instructions, orchestrating timing and coordination. The output logic module drives display signals and generates peak output. Overall, the components work together to execute and control operations in the system. 
 
Here is an overview of the instructions supported by the processor. There are two instructions, load and copy, that move data within the registers of the processor. The next 10 instructions use data stored in one or two registers, perform an arithmetic or logic operation on them, and store the result in a register. Finally, the last two instructions are immediate, so data from the switches is either added or subtracted from a register. 
 
To encode the mnemonic add R1, R3, the first two digits of the opcode represent whether the instruction is immediate. Because this instruction is not immediate, this is equal to 00. The second two digits are the binary representation of register X, or 1. Digits 5 and 4 are the representation of register Y, or 3. Finally, the last four digits are the unique instruction code of add, or 0010. 
 
The instruction Register is a crucial module in the processor, with the instruction bus as its input and the instruction as its output. Its primary purpose is to temporarily store the current instruction for decoding. At timestep 0, a 10-bit instruction is transferred from the instruction bus to the Instruction Register, utilizing negative-edge triggering aligned with synchronous clocking principles.  
This ensures precise capture of the instruction on the falling edge of the clock signal (CLKb). The stored instruction persists across multiple clock cycles, maintaining integrity throughout the execution of the corresponding operation. The synchronous active-high enable (EN) signal determines whether the register is open to receiving new instructions. Enabled, it seamlessly captures input, facilitating smooth transitions between different instructions as the processor progresses. The Instruction Register thus serves as a pivotal component, offering a stable and accessible location for the current instruction, crucial for subsequent decoding and execution stages in the processor's operation. 

The counter module takes different control signals as inputs, generating the program counter as its output. Its core function is to manage program flow and memory addresses. Specifically, the Timestep Counter, implemented as the "upcount2" module, plays a vital role in overseeing program flow and memory address management within the processor. Operating as a 2-bit up-counter, it keeps track of the current timestep of the processed instruction.  
Controlled by negative-edge triggering and an active-high synchronous clear signal (CLR), the counter ensures precise state transitions. Input control signals, including CLR and negative-edge clock signal (CLKb), enable synchronization. The 2-bit output (CNT) serves as the Program Counter, indicating the memory address for the next instruction. In essence, the Timestep Counter contributes to the systematic progression of program execution, ensuring coordinated and synchronized operation within the processor. 
 
 
 
The register file in this processor design features 4 10-bit registers and is structured with one write port and two read ports. Input control signals, including data input (D) and address inputs for write and read operations (WRA, RDA0, RDA1), along with write (ENW) and read (ENR0, ENR1) enable signals, drive its functionality and the output is the data output. This module serves to provide a centralized and organized mechanism for storing and retrieving data, facilitating seamless communication among processor components. During a write operation, triggered by the debounced clock signal (CLKb) and the assertion of the write enable signal (ENW), the Register File stores the data input value into the specified write address, ensuring precise and synchronous data storage. Read operations are combinational, independent of the clock signal, with outputs reflecting values stored in registers associated with specified read addresses when read signals (Q0 or Q1) are active. The design emphasizes efficiency, scalability, and resource-effective engineering. 
 
 
The multi-stage ALU is a crucial computational engine in the processor, executing diverse arithmetic and logic operations on register stored data. It employs a two-stage process using the 'A' register to stage inputs for operations and operates on synchronized, negative-edge-triggered clock signals. Key inputs include the data input (OP) and control signals (FN, Ain, Gin, Gout, CLKb), with the result of the computation (Q) as the output. The ALU's functionality, determined by the FN input and corresponding ALUcont control signals, enhances the processor's capability to perform efficient arithmetic and logic operations on input data. 
 
 
 
The Processor Controller stands as the central orchestrator within the processor architecture, embodying the 'brains' of the system. Its fundamental role is to process incoming instructions and generate a set of control signals that govern various aspects of the processor's functionality. The inputs to the controller include the instruction obtained from the instruction register, while the outputs encompass a spectrum of control signals crucial for coordinating the operation of different modules within the processor. The control signals are essential for steering the processor through different states. The complexity of the controller lies in its ability to interpret the current instruction (INSTR) and the timestep (T) to determine the appropriate set of control signals. The controller essentially acts as the decision-making entity, executing combinational logic that is contingent on the specific instruction and the temporal context. It plays a pivotal role in synchronizing the activities of various modules within the processor, ensuring an organized execution of instructions. 
 
 
 
The Output Logic module plays a crucial role in making the internal signals of the processor visible for testing and demonstration purposes. Acting as a bridge between the processor's internal workings and external displays, the Output Logic takes inputs such as the current data on the shared bus (BUS), the output of the second read port on the register file (REG), and the current timestep of the processor (TIME). The outputs include LED B, which reflects the current values on the data bus, and THEX, a display showing the current timestep decoded for a 7-segment display. Additionally, the module dynamically controls the DHEX2:0 outputs based on the value of PEEKb, enabling users to 'peek' into the processor's registers. If PEEKb is logic-0, DHEX 1 to 0 displays the 10-bit value on the data bus, while, if it's logic-1, DHEX 1 to 0 shows the 10-bit output of the second read port of the register file, allowing observation of register contents. The Output Logic also responds to the "Clr" signal from the controller, activating the LED DONE output to signify the completion of the current instruction. 
 
 
In the T0 phase, corresponding to the instruction load, the processor activates signals under controller guidance, facilitating the loading of instructions from external memory into the instruction register. Once loaded, the processor is primed for subsequent decoding and execution phases, setting the stage for instruction processing. 
During the memory movement phase, the controller manages signals for data transfer between registers and memory locations. This involves loading and storing data at specified memory addresses, crucial for maintaining proper information flow within the processor. 
In the single operand ALU instructions phase, the processor, guided by the controller, executes arithmetic and logic operations on a single operand. The instruction dictates the operation, and the ALU processes data accordingly. This phase highlights the processor's flexibility in handling diverse operations on individual data elements. 

 
During the two operand ALU instructions phase, the processor executes instructions that involve operations on two operands. These instructions can include arithmetic operations like addition or subtraction, as well as logical operations such as AND, OR, and XOR. The controller coordinates the inputs to the ALU, managing the data flow from the register file to the ALU and back. 
Immediate Instructions involve operations where the data to be processed is immediately available within the instruction itself, rather than fetched from memory or registers. During the execution of Immediate Instructions, the processor directly uses the immediate values specified in the instruction to perform the desired operation. This type of instruction is particularly useful for operations that involve constants or values that don't need to be fetched from memory. 
 
 
 
The SystemVerilog implementation of the controller module interprets a 10-bit instruction, decoding it based on the opcode to generate essential control signals for coordinating processor operations. It considers the current timestep for signal synchronization. The implementation employs a time-instruction table to map control signals to timesteps, acting as a guide during instruction execution. The controller manages diverse operations, including memory movement and various ALU instructions. Leveraging SystemVerilog's capabilities, it dynamically generates control outputs, ensuring smooth program execution on the 10-bit processor. The systematic approach to the controller is pivotal for overall processor functionality, determining how components collaborate for timely and coherent instruction execution. 
 
 
 
In implementing the 10-bit processor on the DE10-Lite board, crucial input and output assignments facilitate communication with the external environment. Data Inputs from sliding switches SW[9:0] allow external data input, and the negative-edge clock signal CLKb from the KEY0 button ensures synchronous clocking. The PKb (Peek Key) signal linked to KEY1 initiates the "peek" operation. Outputs include the Data Bus (LEDB) connected to LEDR[9:0] for visualizing current data bus values.   Data Bus/Register Peek (DHEX2:0) mapped to HEX2:0 displays values on the data bus or second read port output. Current Timestep (THEX) on HEX5 shows the processor's timestep, and the Done Signal on HEX5's DP indicates completed instructions. This precise mapping ensures seamless integration and efficient observation of the processor's internal state on the DE10-Lite board. The use of structural SystemVerilog in the top-level module enhances design clarity and maintainability. 
